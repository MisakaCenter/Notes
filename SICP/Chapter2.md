# SICP魔法笔记，Part 2
作者 @MisakaCenter

编程的本质是表达大脑中的概念，隐藏不必要的信息，构造抽象。


将抽象作为克服复杂性的一种技术。


## 1. 数据抽象

将一个复合数据对象的使用，与该数据对象是如何通过更基本的数据对象构造起来的细节隔离开来。

抽象屏障：将使用数据抽象的程序（上层）和实现数据抽象的程序（下层）分隔开来。

- 数据可以定义为一组满足特定概念的选择函数和构造函数，可作为抽象数据实现的基础。

- 只需要满足选择函数与构造函数的假设

例子：序对的一种实现

```Scheme
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else 
           (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1)) 
```

- 闭包性质：某种组合数据对象的操作满足闭包性质，则它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。

- 表是指那些有表尾结束标记的序对的链，表结构是指所有有序对构造起来的数据结构。

- 高阶过程：map，只需要定义对表元素的通用过程即可

- 分层设计方法：更加健壮，每一层都有完整的功能，对于小的改动不敏感

- 符号数据：用任意符号作为数据，quote

对通用界面过程-数据类型二维表格的不同处理方式：

- 数据导向：通过操作名和表示方法从表中获得对应的通用界面过程
- 增加类型标识：不同表示方法中通用
- 消息传递：不同操作上通用

## 2. 带有通用型操作的系统

类型注册：提供数据的类型标识

强制类型转换

类型的层次结构：
- 类型塔：下一层的类型称为上一层类型的子类型，上一层类型称为下一层类型的超类型
  - 子类型可以提升至超类型，超类型可以下降到子类型
- 当系统遇到需要对两个不同类型的运算时，就逐步提升较低类型直到所有对象都处于同一层次

## 3. 赋值

函数式：不用任何赋值；能使用代换模型；相同参数调用同一函数，结果相同。
命令式：使用赋值；使用环境模型；需要仔细考虑赋值的相对顺序（不同顺序，结果不同）

赋值操作 set! ：对自己的局部状态变量进行更新赋值。
- 优点：与纯函数式相比（所有状态都必须显式地操作和传递额外参数），通过引进赋值和将状态隐藏在局部变量中，更利于模块化（使得实现细节完全独立于程序的其他部分）
- 缺点：
    - 变量的值可以改变（变量不再是值的名字，而是索引了保存值的地址），无法使用代换模型。
    - 无法确定两个对象“同一”
    - 会破坏语言的引用透明性（同一的东西可以相互替换）

环境模型：
- 环境是求值过程的上下文
- 创建过程：lambda，在环境中的框架添加一个符号指向对应的lambda过程
- 过程应用：
  - 创建一个新环境，其中包含所有形参约束于对应的实际参数的框架
  - 新框架的外围环境就是该过程的环境（通过该过程指向的环境来确定）
  - 在新环境中求值该过程的过程体（通过该过程指向的过程体来确定）

局部过程：
- 由于局部过程名都是在该过程运行时创建的框架内进行约束的，并不是在全局环境中进行约束的。
- 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程（局部过程的外部过程）的实际参数。因为对于局部过程体的求值是外部过程求值所在的环境的下属。

## 4. 流
- 只计算需要的部分
- 使用delay和force来实现流
- 使用递归定义构造无穷流
- 延迟求值

```Scheme
(cons-stream <a> <b>) ;stream
(cons <a> (delay <b>)) ;等价于

(delay <exp>)
(lambda () <exp>) ;等价于

(define (force delayed_object)
    (delayed_object)) ;求值

(define ones (cons-stream 1 ones)) ;1的无穷流

(define integers (cons-stream 1 (add-streams ones integers))) ;整数的无穷流
```

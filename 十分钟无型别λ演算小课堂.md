# 十分钟无型别λ演算小课堂

作者：MisakaCenter

λ演算，也就是lambda calculus，是一种非常简单而且图灵完备的计算表达式，非常易于拓展，增加各种你想要的语言特性。

Untyped lambda calculus非常简单，以至于它的最简单的AST（抽象语法树）可以定义如下（非形式化）：

```ocaml
tm :=
	|var x
	|abs x tm
    |app tm tm
```

这样我们就有了变元、函数抽象以及函数应用，理论上就可以基于此建立起整个计算机大厦了！

举个例子，下面就是一个函数抽象（abs），可以理解为 输入x，返回x
$$
\lambda x.x
$$
下面就是把变元y应用到这个函数（app）
$$
(\lambda x.x) y
$$
假设我们已经在里面定义好了数以及有关数的运算（也是一堆函数的应用），我们就可以写出这样的式子
$$
(\lambda y.((\lambda x.x+y+3)2))3
$$
到此为止，我们已经能够根据规则写出一大堆lambda calculus的表达式了，接下来我们需要定义计算的规则

首先是alpha-conversion，就是说把一个函数抽象绑定的变元名称改掉和原来的函数抽象是等价的，这个很好理解，也就是
$$
\lambda x.x = \lambda y.y
$$
然后就可以定义beta-reduction，就是将函数抽象的形参全部换为实参的操作，例如
$$
(\lambda x.x+1) 2=2+1=3
$$
这样看来只需要把函数抽象里所有和形参名字相同的自由变量都替换成实参就可以实现beta-reduction了，但是并没有这么简单，考虑这样一个lambda表达式：
$$
(\lambda x.(\lambda y.x+y))y
$$
提问：这个式子经过一步beta-reduction的结果是？

回答：
$$
\lambda y. y+y
$$
这显然是不对的，因为如果我们先对内层的式子做一次alpha-conversion
$$
\lambda y.x+y = \lambda z.x+z
$$
 然后带入到上式，再做一次beta-reduction
$$
(\lambda x.(\lambda y.x+y))y = (\lambda x.(\lambda z.x+z))y = \lambda z.y+z
$$
显然
$$
\lambda y.y+y \neq \lambda z.y+z
$$
改个名字，语义就不同了，发肾什么事了？原来是我们替换的操作有问题！

如果有变元在替换项里是自由的，但在被替换项里是受函数抽象约束的，那我们就需要先修改函数抽象绑定的形参名，然后再进行替换，所以对于上面这个式子 ，右边的替换过程才是正确的结果。

以上就是十分钟UTLC小课堂的全部内容。